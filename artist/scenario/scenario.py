import logging
import pathlib
from collections import defaultdict

import h5py
import torch
from typing_extensions import Self

from artist.data_loader import h5_loader
from artist.field.heliostat_field import HeliostatField
from artist.field.heliostat_group import HeliostatGroup
from artist.field.tower_target_areas import TowerTargetAreas
from artist.scene.light_source_array import LightSourceArray
from artist.util import config_dictionary
from artist.util.environment_setup import get_device

log = logging.getLogger(__name__)
"""A logger for the scenario."""


class Scenario:
    """
    Define a scenario loaded by ''ARTIST''.

    Attributes
    ----------
    power_plant_position : torch.Tensor
        The position of the power plant as latitude, longitude, altitude.
        Tensor of shape [3].
    target_areas : TowerTargetAreas
        All target areas on all towers of the power plant.
    light_sources : LightSourceArray
        A list of light sources included in the scenario.
    heliostat_field : HeliostatField
        The heliostat field for the scenario.

    Methods
    -------
    load_scenario_from_hdf5()
        Class method to load the scenario from an HDF5 file.
    index_mapping()
        Create an index mapping from heliostat names, target area names and incident ray directions.
    """

    def __init__(
        self,
        power_plant_position: torch.Tensor,
        target_areas: TowerTargetAreas,
        light_sources: LightSourceArray,
        heliostat_field: HeliostatField,
    ) -> None:
        """
        Initialize the scenario.

        A scenario defines the physical objects and scene to be used by ``ARTIST``. Therefore, a scenario contains at
        least one target area that is a receiver, at least one light source and at least one heliostat in a heliostat field.
        ``ARTIST`` also supports scenarios that contain multiple target areas, multiple light sources, and multiple heliostats.
        (Note: Currently only a single light source can be provided.)

        Parameters
        ----------
        power_plant_position : torch.Tensor,
            The position of the power plant as latitude, longitude, altitude.
            Tensor of shape [3].
        target_areas : TargetAreaArray
            A list of tower target areas included in the scenario.
        light_sources : LightSourceArray
            A list of light sources included in the scenario.
            Currently only a single light source can be provided.
        heliostat_field : HeliostatField
            A field of heliostats included in the scenario.
        """
        self.power_plant_position = power_plant_position
        self.target_areas = target_areas
        self.light_sources = light_sources
        self.heliostat_field = heliostat_field

    @staticmethod
    def get_number_of_heliostat_groups_from_hdf5(scenario_path: pathlib.Path) -> int:
        """
        Get the number of heliostat groups to initiate distributed setup from the HDF5 scenario file.

        Parameters
        ----------
        scenario_path : pathlib.Path
            File path to the HDF5 scenario file.

        Returns
        -------
        int
            Number of heliostat groups to initiate distributed setup.
        """
        with h5py.File(scenario_path) as scenario_file:
            number_of_groups = scenario_file[
                config_dictionary.number_of_heliostat_groups
            ][()]
        return number_of_groups

    @classmethod
    def load_scenario_from_hdf5(
        cls,
        scenario_file: h5py.File,
        number_of_surface_points_per_facet: torch.Tensor = torch.tensor([50, 50]),
        change_number_of_control_points_per_facet: torch.Tensor | None = None,
        device: torch.device | None = None,
    ) -> Self:
        """
        Class method to load the scenario from an HDF5 file.

        Parameters
        ----------
        scenario_file : h5py.File
            The config file containing all the information about the scenario being loaded.
        number_of_surface_points_per_facet : torch.Tensor
            The number of sampling points along each direction of each 2D facet (default is torch.tensor([50,50])).
            Tensor of shape [2].
        change_number_of_control_points_per_facet : torch.Tensor | None
            The updated number of control points along each direction of each 2D facet (default is None).
            Providing this parameter should be done with caution. In a scenario with surfaces generated by deflectometry,
            this parameter should be None, otherwise the deflectometry surface will be overwritten and become ideal.
            For ideal surfaces this parameter can be used to change the number of control points specified in the .h5 scenario.
            Tensor of shape [2].
        device : torch.device | None
            The device on which to perform computations or load tensors and models (default is None).
            If None, ''ARTIST'' will automatically select the most appropriate
            device (CUDA or CPU) based on availability and OS.

        Returns
        -------
        Scenario
            The ``ARTIST`` scenario loaded from the HDF5 file.
        """
        device = get_device(device=device)

        rank = (
            torch.distributed.get_rank()
            if torch.distributed.is_available() and torch.distributed.is_initialized()
            else 0
        )
        if rank == 0:
            log.info(
                f"Loading an ``ARTIST`` scenario HDF5 file. This scenario file is version {scenario_file.attrs['version']}."
            )

        power_plant_position = torch.tensor(
            scenario_file[config_dictionary.power_plant_key][
                config_dictionary.power_plant_position
            ][()]
        )
        target_areas = TowerTargetAreas.from_hdf5(
            config_file=scenario_file, device=device
        )
        light_sources = LightSourceArray.from_hdf5(
            config_file=scenario_file, device=device
        )

        prototype_surface = h5_loader.surface_config(
            prototype=True, scenario_file=scenario_file, device=device
        )

        prototype_initial_orientation = torch.tensor(
            scenario_file[config_dictionary.prototype_key][
                config_dictionary.kinematic_prototype_key
            ][config_dictionary.kinematic_initial_orientation][()],
            dtype=torch.float,
            device=device,
        )

        prototype_kinematic_type = scenario_file[config_dictionary.prototype_key][
            config_dictionary.kinematic_prototype_key
        ][config_dictionary.kinematic_type][()].decode("utf-8")

        prototype_kinematic_deviations, number_of_actuators = (
            h5_loader.kinematic_deviations(
                prototype=True,
                kinematic_type=prototype_kinematic_type,
                scenario_file=scenario_file,
                log=log,
                device=device,
            )
        )

        prototype_kinematic = {
            config_dictionary.kinematic_type: prototype_kinematic_type,
            config_dictionary.kinematic_initial_orientation: prototype_initial_orientation,
            config_dictionary.kinematic_deviations: prototype_kinematic_deviations,
        }

        prototype_actuator_keys = list(
            scenario_file[config_dictionary.prototype_key][
                config_dictionary.actuators_prototype_key
            ].keys()
        )

        prototype_actuator_type_list = []
        for key in prototype_actuator_keys:
            prototype_actuator_type_list.append(
                scenario_file[config_dictionary.prototype_key][
                    config_dictionary.actuators_prototype_key
                ][key][config_dictionary.actuator_type_key][()].decode("utf-8")
            )

        unique_prototype_actuators = {a for a in prototype_actuator_type_list}

        if prototype_kinematic_type == config_dictionary.rigid_body_key:
            if len(unique_prototype_actuators) > 1:
                raise ValueError(
                    "There is an error in the prototype. When using the Rigid Body Kinematic, all actuators for this prototype must have the same type."
                )
            else:
                prototype_actuator_type = prototype_actuator_type_list[0]

        prototype_actuator_parameters = h5_loader.actuator_parameters(
            prototype=True,
            scenario_file=scenario_file,
            actuator_type=prototype_actuator_type,
            number_of_actuators=number_of_actuators,
            initial_orientation=prototype_initial_orientation,
            log=log,
            device=device,
        )

        prototype_actuators = {
            config_dictionary.actuator_type_key: prototype_actuator_type,
            config_dictionary.actuator_parameters_key: prototype_actuator_parameters,
        }

        heliostat_field = HeliostatField.from_hdf5(
            config_file=scenario_file,
            prototype_surface=prototype_surface,
            prototype_kinematic=prototype_kinematic,
            prototype_actuators=prototype_actuators,
            number_of_surface_points_per_facet=number_of_surface_points_per_facet.to(
                device
            ),
            change_number_of_control_points_per_facet=change_number_of_control_points_per_facet,
            device=device,
        )

        return cls(
            power_plant_position=power_plant_position,
            target_areas=target_areas,
            light_sources=light_sources,
            heliostat_field=heliostat_field,
        )

    def index_mapping(
        self,
        heliostat_group: HeliostatGroup,
        string_mapping: list[tuple[str, str, torch.Tensor]] | None = None,
        single_incident_ray_direction: torch.Tensor = torch.tensor(
            [0.0, 1.0, 0.0, 0.0]
        ),
        single_target_area_index: int = 0,
        device: torch.device | None = None,
    ) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Create an index mapping from heliostat names, target area names and incident ray directions.

        If no mapping is provided, a default mapping for all heliostats within this group will be created.
        The default mapping will map all heliostats to the default ``single_incident_ray_direction``, which
        simulates a light source positioned in the south and the default ``single_target_area_index``, which
        is 0. To overwrite these defaults, please provide a ``single_incident_ray_direction`` or a
        ``single_target_area_index``.

        Parameters
        ----------
        heliostat_group : HeliostatGroup
            The current heliostat group.
        string_mapping : list[tuple[str, str, torch.Tensor]] | None
            Strings that map heliostats to target areas and incident ray direction tensors (default is None).
        single_incident_ray_direction : torch.Tensor
            The default incident ray direction (default is torch.tensor([0.0, 1.0, 0.0, 0.0])).
            Tensor of shape [4].
        single_target_area_index : int
            The default target area index (default is 0).
        device : torch.device | None
            The device on which to perform computations or load tensors and models (default is None).
            If None, ''ARTIST'' will automatically select the most appropriate
            device (CUDA or CPU) based on availability and OS.

        Returns
        -------
        torch.Tensor
            The mask specifying which heliostat is selected and how many times.
            Tensor of shape [number_of_heliostats_in_group].
        torch.Tensor
            The indices of target areas for all selected heliostats in order.
            Tensor of shape [number_of_active_heliostats_in_group].
        torch.Tensor
            The incident ray directions for the selected heliostats in order.
            Tensor of shape [number_of_active_heliostats_in_group, 4].
        """
        device = get_device(device=device)

        data_per_heliostat = defaultdict(list)

        if string_mapping is None:
            if (
                single_incident_ray_direction.shape != torch.Size([4])
                or single_incident_ray_direction[3] != 0.0
                or torch.norm(single_incident_ray_direction) != 1.0
            ):
                raise ValueError(
                    "The specified single incident ray direction is invalid. Please provide a normalized 4D tensor with last element 0.0."
                )
            if single_target_area_index >= self.target_areas.number_of_target_areas:
                raise ValueError(
                    f"The specified single target area index is invalid. Only {self.target_areas.number_of_target_areas} target areas exist in this scenario."
                )
            active_heliostats_mask = torch.ones(
                heliostat_group.number_of_heliostats, dtype=torch.int32, device=device
            )
            target_area_mask = torch.tensor(
                single_target_area_index, dtype=torch.int32, device=device
            ).expand(heliostat_group.number_of_heliostats)
            incident_ray_directions = single_incident_ray_direction.expand(
                heliostat_group.number_of_heliostats, -1
            ).to(device)
        else:
            filtered_mapping = [
                mapping
                for mapping in string_mapping
                if mapping[0] in heliostat_group.names
            ]
            errors = []
            for i, (heliostat_name, target_name, light_direction) in enumerate(
                filtered_mapping
            ):
                if target_name not in self.target_areas.names:
                    errors.append(
                        f"Invalid target '{target_name}' (Found at index {i} of provided mapping) not found in this scenario."
                    )
                if (
                    light_direction.shape != torch.Size([4])
                    or not torch.allclose(
                        light_direction[3],
                        torch.tensor(0.0, device=device),
                        rtol=1e-2,
                        atol=1e-2,
                    )
                    or not torch.allclose(
                        torch.norm(light_direction),
                        torch.tensor(1.0, device=device),
                        rtol=1e-4,
                        atol=1e-4,
                    )
                ):
                    errors.append(
                        f"Invalid incident ray direction (Found at index {i} of provided mapping). This must be a normalized 4D tensor with last element 0.0."
                    )
            if errors:
                raise ValueError(" ".join(errors))

            heliostat_name_to_index = {
                heliostat_name: index
                for index, heliostat_name in enumerate(heliostat_group.names)
            }
            active_heliostats_mask = torch.zeros(
                heliostat_group.number_of_heliostats, dtype=torch.int32, device=device
            )
            target_area_mask = torch.empty(
                len(filtered_mapping), dtype=torch.int32, device=device
            )
            incident_ray_directions = torch.empty(
                (len(filtered_mapping), 4), device=device
            )
            heliostat_name_to_index = {
                heliostat_name: index
                for index, heliostat_name in enumerate(heliostat_group.names)
            }
            active_heliostats_mask = torch.zeros(
                heliostat_group.number_of_heliostats, dtype=torch.int32, device=device
            )
            target_area_mask = torch.empty(
                len(filtered_mapping), dtype=torch.int32, device=device
            )
            incident_ray_directions = torch.empty(
                (len(filtered_mapping), 4), device=device
            )

            for i, (heliostat_name, target_name, incident_ray_direction) in enumerate(
                filtered_mapping
            ):
                if heliostat_name in heliostat_group.names:
                    active_heliostats_mask[heliostat_name_to_index[heliostat_name]] += 1
                    data_per_heliostat[heliostat_name].append(
                        [
                            self.target_areas.names.index(target_name),
                            incident_ray_direction,
                        ]
                    )
            index = 0
            for name in heliostat_group.names:
                for target_area_index, incident_ray_direction in data_per_heliostat.get(
                    name, []
                ):
                    target_area_mask[index] = target_area_index
                    incident_ray_directions[index] = incident_ray_direction
                    index += 1

        return (
            active_heliostats_mask,
            target_area_mask,
            incident_ray_directions,
        )

    def __repr__(self) -> str:
        """Return a string representation of the scenario."""
        return (
            f"ARTIST Scenario containing:\n\tA Power Plant located at: {self.power_plant_position.tolist()}"
            f" with {len(self.target_areas.names)} Target Area(s),"
            f" {len(self.light_sources.light_source_list)} Light Source(s),"
            f" and {sum(len(group.names) for group in self.heliostat_field.heliostat_groups)} Heliostat(s)."
        )
